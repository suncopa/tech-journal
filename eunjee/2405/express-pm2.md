### 개요

> 구구절절 설명하기 보다 비슷한 문제를 겪고 있는 분들이 빠르게 문제 해결에 도달할 수 있도록 바로 해결책 제공

- 들어가며 (서론, 트러블슈팅 상황설명)
  - CSAP(클라우드 서비스 보안인증제도) 취약점 진단 결과 x-powered-by 헤더 설정 필요
  - 클라이언트 사이드 앱 자체적으로는 설정할 수 없는 부분이라 웹 서버에서 설정해주거나 서버가 필요했음
  - 웹 서버인 nginx에서 설정해줄 수 있지만, 클라우드 제품은 쿠버네티스 환경으로 nginx를 사용하지 않고 있었음
  - pm2로 리액트 앱을 서빙하고 있었는데, 여기에 express 서버를 사용해 리액트 앱을 호스팅하는 방식으로 해결하기로 함
- 취약점
  - x-powered-by 헤더 설정 : 이에 대한 설명
  - production으로 배포
  - 로그 파일 권한 설정
- 개발 목표
  - express 서버를 통해 리액트 앱을 호스팅하고 pm2로 띄우기
- 리액트 앱의 정적 파일을 서빙하는 express 서버 만들기
  - x-powered-by 헤더 설정
- Dockerfile 권한 설정

----

# 들어가며

바야흐로 일주일 전, 바쁘게 신규 기능을 개발하고 있는 와중에 뜬금 없는, 하지만 아주 중요한 태스크가 하나 제게 주어졌습니다. 현업에 계신 분들은 와 닿으실 수도 있겠는데요. 회사 제품에 국가 공인 인증을 받기 위한 작업으로서 회사 밥벌이에 아주 지대한 영향을 미치는 태스크였습니다.

저는 어려운 기술 문제를 해결하는 데에 큰 재미를 느끼는 편이라 데브옵스 분야에 관심이 있습니다. 경험 상 데브옵스쪽 업무를 해봤을 때 평소에 하는 리액트 개발보다 훨씬 난이도가 높다고 느꼈습니다. 시간이 얼마나 걸리든 끈질기게 물고 늘어져 그 문제를 해결하고 나면 그 성취감은 더욱 달콤하더라구요. (이것도 일종의 도파민 중독 아닐까...)

오늘 설명할 태스크도 데브옵스와 관련이 있었는데요. 단순히 리액트 코드를 수정하면 해결되는 문제가 아니라, 배포 파이프라인을 변경하고 Dockerfile까지 직접 수정해야 했습니다. 여러분들은 정답 코드(?)를 이 글에서 바로 만나보실테지만, 실제로는 문제 정의부터 최종 해결까지 만 5일 정도의 시간이 걸렸습니다.


# 배경 설명

제가 해결해야 했던 문제는 진단받은 프론트엔드 앱의 보안 취약점을 보완하는 것이었습니다. 

1. x-powered-by 헤더 설정
2. node 프로세스 권한 제한
3. 로그 디렉토리 및 파일 권한 및 로그 포맷 설정

# 1. x-powered-by 헤더

## x-powered-by 헤더란?

웹 서버나 애플리케이션 서버가 클라이언트에게 응답할 때, 해당 서버가 어떤 기술이나 프레임워크를 사용했는지를 알려주는 HTTP 응답 헤더입니다.

> x-powered-by 헤더와 프론트엔드 앱(리액트 앱)은 무슨 관계일까?

사실 엄밀하게는 리액트 어플리케이션과 x-powered-by 헤더 간에는 직접적인 상관관계는 없습니다. 왜냐하면 리액트 어플리케이션은 클라이언트 사이드 어플리케이션으로서 HTTP 헤더 설정을 직접적으로 할 수 없기 때문이죠. x-powered-by 헤더는 이 리액트 어플리케이션을 이를 제공하고 있는 웹 서버에 의해 결정됩니다. (nginx, apache 등 웹 서버의 설정을 통해 변경할 수 있습니다.)

하지만 nginx와 같은 웹 서버를 두고 있지 않기 때문에 이를 통한 해결 방법은 불가능했습니다.

## 해결 방법

> 리액트 어플리케이션을 서빙하는 express 서버를 통해 HTTP 헤더 설정을 하자!

기존에는 serve로 pm2를 통해 정적 리소스를 서빙하고 있었는데요. serve 대신 간단한 express 서버를 통해 정적 리소스를 서빙하도록 하고, 이 express 서버를 통해 HTTP 헤더 등의 서버 로직을 추가하기로 결정했습니다.

*serve : 별도의 서버 코드 작성 없이 JavaScript와 Node.js 환경에서 사용되는 경량의 정적 파일 서버 패키지



# 2. node 프로세스 권한 제한 및 실행 모드 설정

## 왜 취약한가?

> 노드 프로세스가 루트 권한으로 실행될 시 위험성

루트 권한으로 실행되는 프로세스는 시스템의 모든 파일과 리소스에 접근할 수 있습니다. 때문에 공격자가 이를 악용하여 민감한 데이터가 유출하거나 루트 권한을 통해 시스템을 장악하여 악성 코드를 주입하는 등이 가능해집니다.

> 프로덕션 모드로 설정되지 않았을 시 위험성

개발 모드에서는 디버깅을 위해 많은 추가 기능이 활성화되어 있어 프로덕션 환경에서의 성능을 저하시킬 수 있습니다. 또한 이러한 디버깅 정보나 에러 메시지가 노출될 경우 공격자에게 내부 구조에 대한 정보를 제공하여 공격하는 데 도움을 줄 수 있습니다.

## 해결 방법

> 비루트 사용자로 노드 프로세스를 실행하고 'NODE_ENV=production'으로 프로덕션 모드를 설정하자!



# 3.로그 디렉토리 및 파일 권한 및 로그 포맷 설정

## 왜 취약한가?

로그 디렉토리 및 파일의 권한이 루트 사용자로 설정되어 있으면 여러 보안상의 문제가 있습니다. node 프로세스 권한으로 인한 문제와 마찬가지로, 공격자가 시스템 로그를 수정하거나 조작할 수 있게 되어 시스템에 대한 침입을 숨기는 데 사용될 수 있습니다. 

## 해결 방법

> Dockerfile에서 로그를 저장하는 폴더를 생성할 때 750 권한을 부여하자!




# 해결 코드 : express 서버로 프론트엔드 앱 서빙 + node 및 로그 설정

현재 프론트엔드 어플리케이션의 배포 및 서빙 과정은 다음과 같습니다.

1. 이미지 빌드
	- `Dockerfile`을 사용하여 Node.js와 Express 및 기타 필요한 의존성을 포함하는 Docker 이미지를 생성합니다. 이 과정에서 프론트엔드 빌드 파일(`build/`)도 이미지에 포함됩니다.
2. 컨테이너 생성 및 실행
	- `startup.sh` 스크립트를 통해 미리 생성된 이미지를 바탕으로 Docker 컨테이너를 생성하고 실행합니다. 이 스크립트는 컨테이너가 시작될 때 자동으로 실행되어 필요한 서비스가 준비된 상태인지 확인하고, 필요한 환경 변수를 설정합니다.
3. express 서버 구성
	- Express 기반의 웹 서버를 초기화하고 구성합니다. 이 서버는 React 어플리케이션의 정적 리소스를 서빙하는 역할을 합니다. `server.js`에서 정적 파일 경로를 설정하여, `build` 디렉토리에 있는 정적 리소스에 접근할 수 있도록 합니다.
4. pm2를 통한 서버 관리
	- PM2를 사용하여 Express 서버를 관리합니다. `ecosystem.config.js` 파일을 통해 PM2가 어플리케이션을 어떻게 실행할지 구성합니다. 이 구성에는 인스턴스 수, 자동 재시작, 환경 변수 설정 등이 포함됩니다. PM2는 서버의 안정성을 보장하고, 자동 재시작 및 로그 관리 등을 제공합니다.

### 1) 이미지 빌드 : Dockerfile

```

```

### 2) 컨테이너 실행 : startup.sh

### 3) express 서버 구성 : server.js

> 정적 리소스의 디렉토리 위치, 서버 포트 번호 등은 개발 환경에 따라 다르니 유의하자.

```
// server.js

const express = require('express');
const app = express();

app.use(express.static(path.join(__dirname, 'build')));

app.get('*', (req, res) => {
res.sendFile(path.join(__dirname, 'build', 'index.html'));
});

app.disable('x-powered-by');

const port = process.env.PORT || 29000;

app.listen(port, () => {
console.log(`Console is running on http://localhost:${port}`);
});
```



### 4) pm2를 통한 서버 관리 : ecosystem.config.js




