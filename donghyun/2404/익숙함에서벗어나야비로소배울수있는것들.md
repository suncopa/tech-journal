최근에 회사 업무를 벗어난 다양한 활동에서 배우게 된 점들이 많아서
이런 내용들을 정리하여 기록으로 남기고 싶어서 글을 작성하게 되었다.

기존에 꾸준히 진행하던 스터디와 최근 새로운 프로젝트에도 참여하고,
또 서류를 통과해서 과제전형을 진행하면서 생각보다 많은 것들에 대해 배울 수 있었다.

## 1. 모달과 createPortal

지금까지는 아무런 생각 없이 모달을 그냥 사용하는 곳마다 모달의 열림/닫힘 상태를 만들고,
조건부 렌더링으로 군데군데 직접 불러와서 사용하고 있었다.
그런데 이번에 스터디에서 같은 과제를 여러 스터디원들이 각자의 방법으로 구현해왔는데
나와 달리 createPortal로 모달을 관리한 분이 계셨다.

나는 들어만 보고 사용해보지 못했던 것이기 때문에 막 여쭤보았는데
기존 리액트에서 모든 내용을 렌더링하는 root div와 완전히 별개로 독립적인
modal-root를 만들어서 createPortal을 통해 그 내부에 렌더링하기 때문에
기존의 다른 dom요소와 충돌이나 간섭을 일으킬 일이 사라진다는 장점이 있다고 했다.

그렇기 때문에 내가 사용하던 방식에서는 모달에서 스크롤이 발생하면 뒷 배경이 스크롤 되는 이슈가 있어서 따로 css를 건드리는 번거로운 처리를 해 주어야 했는데,
createPortal로 구현한 모달은 구조적으로 그럴 필요가 없다는 장점도 있었다.

전혀 생각해보지 못했던 부분에 대해서 새롭게 알게될 수 있어 너무 흥미로웠지만
한편으로는 익숙함에 절여져 스스로는 문제를 발견하지 못하는 부분이
이 경우 뿐만 아니라 더 많겠구나 라는 생각에 위기감이 느껴지기도 했다.

## 2. URLSearchParams

이 부분은 기업 과제전형을 하면서 뒤늦게 깨닫게 된 점이다.
GET API에서 여러가지 queryString을 요청에 담아서 보내는데
이 때 input으로 받은 여러 query값들을 queryString 형식에 맞게 포매팅 해서 보내야한다.

이 부분은 Object.entries와 배열 메서드를 통해 처리하는 방법이 있고,
URLSearchParams로 해결하는 방법이 있는데

내가 다니던 회사에서는 전부 POST로 처리하다 보니 REST API를 지키지 못했고
queryString이 아니라 그냥 모든 값을 body에 담아서 처리하고 있었다.
그래서 나는 queryString을 처리하는 방법이 익숙치 않았고, 첫번째 방법으로 구현을 했다.

그러나, URLSearchParams를 사용하면 위의 복잡한 처리를 간단하게 처리해주고 가독성도 훨씬 좋기 때문에 이 방법이 훨씬 나은 방법이였던 것을 제출한 후에야 깨달았다.

이 부분을 놓친 것에 대하여 아쉬움이 크지만, 그래도 억울하진 않았다.
애초에 내가 잘 알았다면 절대 놓치고 넘어가지 않았을 부분이였기 때문이다.
과제에서 탈락한다면 내 실력만큼 해서 떨어진거지, 실력만큼 보여주지 못해 떨어진게 아니므로 떨어지더라도 겸허하게 받아들이고, 부족한 부분을 배울 수 있어서 좋았다.

이번에도 위의 모달의 경우와 마찬가지로, 회사에서 늘 하던 익숙한 방식에 빠져서 지금까지 나의 취약점을 스스로 발견하지 못한 경우였다.

## 3. mutation시 주의할 점

이것도 스터디 팀원분을 통해 인사이트를 얻게 된 부분이다.

수정, 삭제 등 기존 데이터를 변경하는 요청이 발생하면
기존 데이터가 즉시 업데이트가 되도록 하는 것은 매우 기본적이다.
swr이나 react query같은 상태관리 라이브러리를 사용하면 쉽게 구현할 수 있는데,

나는 회사에서 로딩이 굉장히 오래 걸리는 데이터에 swr mutate를 사용한 적이 있었다.
데이터 양 자체도 많고, DB도 dynamoDB였기 때문에 말도 안되게도 로딩이 15초 이상 걸렸다.
그래서 그냥 mutate를 해버린다고 하면 어차피 업데이트 되는데 15초가 걸리므로
원래 새로고침 없이도 수정된 데이터를 즉시 반영해주는게 mutate의 장점인데
이러면 새로고침 하는거나 거의 마찬가지라서 UX가 최악이었다.

그래서 내가 생각했던 방법은 어차피 client에서는 어떤 값으로 수정되는지 알기 때문에

1. 서버에 update 요청을 전달
2. update요청 성공시 mutate를 통해 swr 내부에 캐싱된 값을 수정
3. 따로 서버로부터 get요청 없이도 업데이트된 데이터가 즉시 반영

이렇게 처리하면 API call도 줄일 수 있고 UX도 개선할 수 있는 **완벽한 방법**이라고 생각했다.

그러나 스터디원분은 이러면 결국 유저가 보는 데이터는 DB로부터 받아온 최신 데이터라고 확실한 보장을 할 수 없기 때문에 **매우 위험한 방식**이라는 피드백을 주셨다.
처음에는 update요청이 성공해야만 캐싱값에 mutate를 주기 때문에
안전하다고 생각해서 스터디원분이 주신 피드백을 이해할 수 없었으나,
최신 데이터임을 확실히 보장할 수 있는지 곰곰히 생각해본 결과,
그렇지 않다는 것을 깨닫게 되었다.

이 방식대로라면 여러 명의 유저가 같은 데이터에 update 요청을 보냈을 때
다들 자기가 update한 데이터만 반영된 값만 보게 될 것이고,
db의 실제 데이터와 각 유저들이 보고 있는 데이터는 완전히 달라지는 대참사가 일어날 것이였다.

이 방식은 결국 단 한명만 수정하고 단 한명만 볼 수 있는 데이터가 아니라면
절대로 사용해서는 안되는 굉장히 위험한 방식이였음을 깨달을 수 있었다.

나는 회사에서 극 소수만 사용하는 사내 백오피스 툴을 개발하고 있었기 때문에
위와 같은 방식으로 개발해도 부작용을 경험하지 못했던 것 뿐이였다.

## 결론

**회사 개발 환경에서 벗어난 다양한 환경에서의 경험을 쌓아야겠다**는 생각이 확고해졌다.
각자 다른 회사, 다른 환경에서 개발하는 다른 개발자분들의 코드를 보며 대화하고
프로젝트 팀원의 코드도 보고, 다른 회사의 과제 코드도 보면서
마치 익숙한 한국을 떠나 해외여행을 통해 생소한 경험을 한 것처럼

> '당연하다고 여기던 것들이 사실은 당연하지 않은 것들이였음'을 깨닫게 되었다.

한국에 계속 살면서 한국의 장점이나 단점에 대해서 자각하기는 굉장히 쉽지않다.
예를 들면 한국인들은 크리스마스가 **'당연히'** 휴일일 것으로 생각하지만
사실 바로 옆나라인 일본, 중국은 크리스마스에도 출근한다.
이런 사실을 알아야 크리스마스에 쉬는 것이 **'당연하지 않은 것'**임을 느낄 수 있다.

이처럼 나도 고작 1년 다닌 회사지만 '**당연하다고 생각하게 된 것**'들이 많아졌던 것 같다.
이런 것들이 당연하지 않은 것임을 깨닫기 위해서는,
익숙한 그 환경 속에서 문제를 찾아내려고 하는 방법보단
다른 환경에 자신을 노출시키면서 비교를 통해 문제를 발견하는 방법이 훨씬 효과적인 것 같다.

이번 경험을 통해서 익숙한 환경의 위험성에 대해 정말 크게 느낄 수 있었다.
앞으로는 의도적으로 스스로를 새롭고 다양한 환경에 계속 집어던져야겠다.
